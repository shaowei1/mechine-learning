from tree import createDataSet, createTreefrom treePlotter import retrieveTree, createPlot"""决策树非常好的匹配了实验数据，然而只写匹配选项可能太多了，我们将这种问题称为过度匹配(overfitting).为了减少过度匹配问题，我们可以裁剪决策树，去掉一些不必要的叶子节点.如果叶子节点只能增加少许信息，则可以删除该节点，并将他加入其他叶子节点中本章采用的算法叫做ID3, 无法直接处理数值型数据，尽管我们可以通过量化的方法将数值型数据转化为标称型数据，但是存在提案多的特征划分，第九章学习另一个决策树构造算法CART, C4.5"""def classify(inputTree, featLabels, testVec):    """    在实际数据集中改属性存储在哪个位置? 是第一个属性还是第二个属性?    :param inputTree:    :param featLabels:    :param testVec:    :return:    """    firstStr = list(inputTree.keys())[0]    secondDict = inputTree[firstStr]    # 将标签字符串转换为索引, 使用index方法查找当前列表中第一个匹配firstStr变量的元素    featIndex = featLabels.index(firstStr)    for key in secondDict.keys():        # 比较testVec变量中的值与树节点的值        if testVec[featIndex] == key:            if type(secondDict[key]).__name__ == 'dict':                classLabel = classify(secondDict[key], featLabels, testVec)            else:                # 如果到达叶子节点，返回当前节点的分类标签                classLabel = secondDict[key]    return classLabeldef storeTree(inputTree, filename):    """    使用pickle序列化对象在磁盘中保存对象,并在需要的时候取出来    :param inputTree:    :param filename:    :return:    """    import pickle    fw = open(filename, 'wb')    pickle.dump(inputTree, fw)    fw.close()def grabTree(filename):    import pickle    fr = open(filename, 'rb')    return pickle.load(fr)if __name__ == '__main__':    fr = open('lenses.txt')    lenses = [inst.strip().split('\t') for inst in fr.readlines()]    # “年龄”、“规定”、“散光”、“流泪率”    lensesLabels = ['age', 'prescript', 'astigmatic', 'tearRate']    lensesTree = createTree(lenses, lensesLabels)    print(lensesTree)    print(lensesLabels)    createPlot(lensesTree)    # test about product tree    # myData, labels = createDataSet()    # print(labels)    # myTree = retrieveTree(0)    # print(myTree)    # test store and write tree    # storeTree(myTree, 'classifierStorage.txt')    # res = grabTree('classifierStorage.txt')    # 测试测试算法: 使用决策树执行分类    # a = classify(myTree, labels, [1, 0])    # b = classify(myTree, labels, [1, 1])    # print(a, b)